---
# Copyright (c) IBM Corporation 2025
# tasks file for create_standby

- name: Run initialization tasks
  ansible.builtin.include_tasks: ../../dataguard_precheck/tasks/init.yml
  when: not init_done is defined

- name: Check if Dataguard setup was already done
  block:
    - name: Checking if Dataguard setup was already done
      ansible.builtin.stat:
        path: "{{ done_dir }}/dataguard.success"
      register: dataguarddone
      when: inventory_hostname == primary_host

    - name: Exit if Dataguard setup was already done
      ansible.builtin.fail:
        msg: "Dataguard setup already done. Exiting."
      when:
        - dataguarddone.stat.exists
        - inventory_hostname == primary_host
      run_once: true

    - name: End play if Dataguard setup Task was done
      ansible.builtin.meta: end_play
      when: dataguarddone.stat.exists
      run_once: true

    - name: Checking if Dataguard restore was already done
      ansible.builtin.stat:
        path: "{{ done_dir }}/standby_restore.success"
      register: restoredone
      when: inventory_hostname == standby_host

- name: Fetch DBID and control file location from primary database
  when:
    - inventory_hostname == primary_host
    - restoredone.stat.exists is not defined or not restoredone.stat.exists
  block:
    - name: Copy DBID and control file location script from primary database
      ansible.builtin.template:
        src: primary_dbid.sh
        dest: "{{ scripts_dir }}/primary_dbid.sh"
        mode: '0755'

    - name: Execute DBID and control file location script on primary database
      ansible.builtin.command: "{{ scripts_dir }}/primary_dbid.sh"
      register: precheck_output
      failed_when: precheck_output.rc != 0
      changed_when: false

    - name: Fetch DBID file content
      ansible.builtin.slurp:
        src: "{{ scripts_dir }}/dbid.txt"
      register: dbid_content

    - name: Fetch Controlfile Location content
      ansible.builtin.slurp:
        src: "{{ scripts_dir }}/controlfile_location.txt"
      register: controlfile_content

    - name: Set DBID and control file location as facts
      ansible.builtin.set_fact:
        standby_dbid: "{{ dbid_content['content'] | b64decode | trim }}"
        standby_controlfile_location: "{{ controlfile_content['content'] | b64decode | trim }}"
      when:
        - dbid_content['content'] is defined
        - controlfile_content['content'] is defined

- name: Fetch DBID and control file location facts from primary to standby
  ansible.builtin.set_fact:
    standby_dbid: "{{ hostvars[primary_host].standby_dbid }}"
    standby_controlfile_location: "{{ hostvars[primary_host].standby_controlfile_location }}"
  when:
    - inventory_hostname == standby_host
    - hostvars[primary_host].standby_dbid is defined
    - hostvars[primary_host].standby_controlfile_location is defined
    - restoredone.stat.exists is not defined or not restoredone.stat.exists

- name: Fetch Port from Standby and Update TNS Entry on Primary
  when:
    - not with_backup
    - restoredone.stat.exists is not defined or not restoredone.stat.exists
  block:
    - name: Fetch Available Port from Standby Host Log
      ansible.builtin.shell: "grep 'Available port:' /tmp/ansible/done/standby_tns.log | awk '{print $3}'"
      register: port_result
      changed_when: false
      when:
        - inventory_hostname == standby_host

    - name: Store Available Port as Fact
      ansible.builtin.set_fact:
        free_port: "{{ port_result.stdout }}"
      when:
        - inventory_hostname == standby_host
        - port_result.stdout is defined
        - port_result.stdout | length > 0

    - name: Debug Free Port on Standby
      ansible.builtin.debug:
        msg: "Standby Free Port: {{ free_port }}"
      when: inventory_hostname == standby_host

    - name: Ensure PORT variable is available from standby
      ansible.builtin.set_fact:
        free_port: "{{ hostvars[standby_host]['free_port'] }}"
      when:
        - inventory_hostname == primary_host
        - hostvars[standby_host] is defined
        - hostvars[standby_host].free_port is defined
        - hostvars[standby_host].free_port | length > 0

    - name: Debug Free Port on Primary
      ansible.builtin.debug:
        msg: "Primary Free Port: {{ free_port }}"
      when: inventory_hostname == primary_host

    - name: Remove existing standby database entry from tnsnames.ora
      ansible.builtin.replace:
        path: "{{ databases.primary.oracle_db_home }}/network/admin/tnsnames.ora"
        regexp: '^\s*{{ databases.standby.db_unique_name }}=\s*\(DESCRIPTION\s*=\s*\(ADDRESS_LIST\s*=\s*\(ADDRESS=.*?\)\s*\)\s*\(CONNECT_DATA\s*=\s*\(SERVER=.*?\)\s*\(SERVICE_NAME=.*?\)\s*\)\s*\)\s*'
        replace: ''
        backup: true
      when: inventory_hostname == primary_host

    - name: Add new standby database entry to tnsnames.ora with temporary port
      ansible.builtin.blockinfile:
        path: "{{ databases.primary.oracle_db_home }}/network/admin/tnsnames.ora"
        insertafter: EOF
        create: true
        block: |

          {{ databases.standby.db_unique_name }}=
          (DESCRIPTION =
            (ADDRESS_LIST =
              (ADDRESS=(PROTOCOL=TCP) (HOST={{ standby_host }})(PORT={{ free_port }}))
            )
            (CONNECT_DATA =
              (SERVER=DEDICATED)
              (SERVICE_NAME={{ databases.standby.db_service_name }})
            )
          )
      when: inventory_hostname == primary_host

- name: Run Dataguard Restore Script on standby
  when:
    - inventory_hostname == standby_host
    - not restoredone.stat.exists
  block:
    - name: Copy RMAN restore script for standby
      ansible.builtin.template:
        src: restore_standby_db.sh.j2
        dest: "{{ scripts_dir }}/restore_standby_db.sh"
        mode: '0755'
      vars:
        database_name: "standby"
        dbid: "{{ standby_dbid }}"
        controlfile_location: "{{ standby_controlfile_location }}"

    - name: Execute restore script for standby
      ansible.builtin.command: "{{ scripts_dir }}/restore_standby_db.sh '{{ default_dbpass }}'"
      register: precheck_output
      failed_when: precheck_output.rc != 0
      changed_when: false

    - name: Debug restore Output for standby database
      ansible.builtin.debug:
        msg: "{{ precheck_output.stdout_lines }}"

- name: Validate Dataguard restore Status
  block:
    - name: Checking if Dataguard restore was already done
      ansible.builtin.stat:
        path: "{{ done_dir }}/standby_restore.success"
      register: restoredone
      when: inventory_hostname == standby_host

    - name: Set fact for primary if restore was already done on standby
      ansible.builtin.set_fact:
        restore_done_primary: "{{ restoredone.stat.exists }}"
      when: inventory_hostname == standby_host

    - name: Fetch post restore status from standby to primary
      ansible.builtin.set_fact:
        restore_done_primary: "{{ hostvars[standby_host]['restore_done_primary'] | default(false) }}"
      when: inventory_hostname == primary_host

    - name: Checking if Dataguard post restore was already done
      ansible.builtin.stat:
        path: "{{ done_dir }}/post_restore.success"
      register: postrestoredone
      when: inventory_hostname == standby_host

- name: Run Restore Post-Processing Script on standby
  when:
    - inventory_hostname == standby_host
    - restoredone.stat.exists
    - not postrestoredone.stat.exists
    - with_backup | bool
  block:
    - name: Copy RMAN Restore Post-Processing Script
      ansible.builtin.template:
        src: standby_postcheck.sh
        dest: "{{ scripts_dir }}/standby_postcheck.sh"
        mode: '0755'
      vars:
        database_name: "standby"

    - name: Run RMAN Restore Post-Processing Script
      ansible.builtin.command: "{{ scripts_dir }}/standby_postcheck.sh"
      register: script_output
      changed_when: false

    - name: Display RMAN Restore Post-Processing Script Output
      ansible.builtin.debug:
        msg: "{{ script_output.stdout_lines }}"

- name: Validate Post-Processing Status
  block:
    - name: Checking if Dataguard post restore was already done on standby
      ansible.builtin.stat:
        path: "{{ done_dir }}/post_restore.success"
      register: postrestoredone
      when: inventory_hostname == standby_host

    - name: Set fact for post restore status
      ansible.builtin.set_fact:
        postrestore_status: "{{ postrestoredone.stat.exists | default(false) }}"
      when: inventory_hostname == standby_host

    - name: Retrieve post restore status from standby
      ansible.builtin.set_fact:
        postrestore_status: "{{ hostvars[standby_host].postrestore_status | default(false) }}"
      when: inventory_hostname == primary_host

    - name: Set fact for condition evaluation
      ansible.builtin.set_fact:
        postcheck_required: >-
          {{ (with_backup | bool and postrestore_status | bool) or
             (not with_backup | bool and not postrestore_status | bool) }}

- name: Run Protection Mode Post-Processing on primary
  when:
    - inventory_hostname == primary_host
    - restore_done_primary
    - not dataguarddone.stat.exists
    - postcheck_required
  block:
    - name: Copy Protection Mode Post-Processing Script on primary
      ansible.builtin.template:
        src: primary_postcheck.sh
        dest: "{{ scripts_dir }}/primary_postcheck.sh"
        mode: '0755'
      vars:
        database_name: "primary"

    - name: Execute Protection Mode Post-Processing Script on primary
      ansible.builtin.command: "{{ scripts_dir }}/primary_postcheck.sh"
      register: script_output
      changed_when: false

    - name: Display Protection Mode Post-Processing Output
      ansible.builtin.debug:
        msg: "{{ script_output.stdout_lines }}"
